import fs from "node:fs/promises";
import path from "node:path";
import { pathToFileURL } from "node:url";

const cwd = process.cwd();
const backendRoot = process.env.BACKEND_ROOT
  ? path.resolve(process.env.BACKEND_ROOT)
  : path.resolve(cwd, "../neo3fura");
const failOnFrontendDocGaps = process.env.FAIL_ON_FRONTEND_DOC_GAPS === "1";
const failOnBackendUndocumented = process.env.FAIL_ON_BACKEND_UNDOCUMENTED === "1";
const writeMissingBackendDocs = process.env.WRITE_MISSING_BACKEND_DOCS === "1";
const refreshAutogeneratedBackendDocs = process.env.REFRESH_AUTOGENERATED_BACKEND_DOCS === "1";

const frontendSourceDir = path.resolve(cwd, "src");
const frontendApiDocsCatalogPath = path.resolve(cwd, "src/constants/rpcApiDocs.mjs");
const backendApiConfig = path.resolve(backendRoot, "neo3fura_http/config/config.go");
const backendApiDir = path.resolve(backendRoot, "neo3fura_http/biz/api");
const backendDocsDir = path.resolve(backendRoot, "docs/api");

const passthroughMethods = new Set(["invokefunction", "getapplicationlog", "sendrawtransaction"]);
const docsNoiseMethods = new Set(["transfer", "stake"]);

const frontendPatterns = [/rpcMethod:\s*"([A-Za-z0-9_]+)"/g, /rpc\(\s*"([A-Za-z0-9_]+)"/g];
const backendHandlerPattern = /func \(me \*T\) ([A-Za-z0-9_]+)\(/g;
const backendApiAllowlistPattern = /"([A-Za-z0-9_]+)"\s*:\s*true,/g;
const docsMethodPattern = /"method"\s*:\s*"([A-Za-z0-9_]+)"/g;

async function exists(targetPath) {
  try {
    await fs.access(targetPath);
    return true;
  } catch {
    return false;
  }
}

async function walkFiles(rootDir, predicate, found = []) {
  const entries = await fs.readdir(rootDir, { withFileTypes: true });
  for (const entry of entries) {
    const full = path.join(rootDir, entry.name);
    if (entry.isDirectory()) {
      await walkFiles(full, predicate, found);
      continue;
    }
    if (predicate(full)) found.push(full);
  }
  return found;
}

function collectMatches(content, patterns) {
  const out = new Set();
  for (const pattern of patterns) {
    let match;
    pattern.lastIndex = 0;
    while ((match = pattern.exec(content)) !== null) {
      if (match[1]) out.add(match[1]);
    }
  }
  return out;
}

function sorted(setOrArray) {
  return [...setOrArray].sort((a, b) => a.localeCompare(b));
}

function findDuplicates(values) {
  const counts = new Map();
  for (const value of values) {
    counts.set(value, (counts.get(value) ?? 0) + 1);
  }
  return sorted([...counts.entries()].filter(([, count]) => count > 1).map(([value]) => value));
}

export function collectApiDocsCatalogIssues({ categories, methods, passthroughMethods }) {
  const safeCategories = Array.isArray(categories) ? categories : [];
  const safeMethods = Array.isArray(methods) ? methods : [];
  const passthrough =
    passthroughMethods instanceof Set ? passthroughMethods : new Set(passthroughMethods ?? []);

  const categoryKeys = safeCategories.map((category) => category?.key).filter(Boolean);
  const methodNames = safeMethods.map((method) => method?.name).filter(Boolean);
  const categoryKeySet = new Set(categoryKeys);
  const methodByName = new Map();
  for (const method of safeMethods) {
    if (!method || !method.name) continue;
    methodByName.set(method.name, method);
  }

  const methodsWithUnknownCategory = sorted(
    new Set(
      safeMethods
        .filter((method) => method?.name && method?.category && !categoryKeySet.has(method.category))
        .map((method) => method.name)
    )
  );

  const passthroughMethodTypeMismatches = sorted(
    [...passthrough].filter((methodName) => methodByName.get(methodName)?.type !== "passthrough")
  );

  const passthroughTypeMissingFromSet = sorted(
    safeMethods
      .filter((method) => method?.name && method?.type === "passthrough" && !passthrough.has(method.name))
      .map((method) => method.name)
  );

  return {
    duplicateCategoryKeys: findDuplicates(categoryKeys),
    duplicateMethodNames: findDuplicates(methodNames),
    methodsWithUnknownCategory,
    passthroughMethodTypeMismatches,
    passthroughTypeMissingFromSet,
  };
}

export function collectApiDocsCatalogUsageIssues({ catalogMethodNames, frontendMethodNames }) {
  const catalog = Array.isArray(catalogMethodNames)
    ? catalogMethodNames.filter((method) => typeof method === "string")
    : sorted(catalogMethodNames ?? []);
  const frontend =
    frontendMethodNames instanceof Set ? frontendMethodNames : new Set(frontendMethodNames ?? []);

  return {
    catalogMethodsMissingInFrontendUsage: sorted(
      new Set(catalog.filter((methodName) => !frontend.has(methodName)))
    ),
  };
}

export function findMissingMethods({ requiredMethods, availableMethods, exemptMethods = new Set() }) {
  const required = Array.isArray(requiredMethods) ? requiredMethods : sorted(requiredMethods ?? []);
  const available = availableMethods instanceof Set ? availableMethods : new Set(availableMethods ?? []);
  const exempt = exemptMethods instanceof Set ? exemptMethods : new Set(exemptMethods ?? []);

  return required.filter((method) => !available.has(method) && !exempt.has(method));
}

export function buildHandlerCoverageSet(handlerMethods) {
  const handlers = handlerMethods instanceof Set ? handlerMethods : new Set(handlerMethods ?? []);
  const coverage = new Set();
  for (const method of handlers) {
    if (typeof method !== "string" || method.length === 0) continue;
    coverage.add(method);
    coverage.add(`${method.slice(0, 1).toLowerCase()}${method.slice(1)}`);
  }
  return coverage;
}

function escapeRegExp(input) {
  return input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

export function methodToDocFileName(method) {
  if (!method || typeof method !== "string") return null;
  return `${method.slice(0, 1).toLowerCase()}${method.slice(1)}.md`;
}

export function extractMethodArgsFromApiSource(source, method) {
  if (!source || !method) return [];

  const structArgsPattern = new RegExp(
    `func \\(me \\*T\\) ${escapeRegExp(method)}\\(args\\s+struct\\s*\\{([\\s\\S]*?)\\}\\s*,\\s*ret\\s+\\*json\\.RawMessage\\)`,
    "m"
  );
  const match = structArgsPattern.exec(source);
  if (!match) return [];

  const structBody = match[1];
  const out = [];
  for (const rawLine of structBody.split("\n")) {
    const withoutComment = rawLine.replace(/\/\/.*$/, "").trim();
    if (!withoutComment) continue;

    const normalized = withoutComment.replace(/`[^`]*`/g, "").trim();
    const fieldMatch = /^([A-Za-z_][A-Za-z0-9_]*)\s+(.+)$/.exec(normalized);
    if (!fieldMatch) continue;

    out.push({
      name: fieldMatch[1],
      type: fieldMatch[2].trim(),
    });
  }
  return out;
}

function inferExampleValue(type) {
  const normalized = String(type || "").toLowerCase().trim();
  const dereferenced = normalized.replace(/^\*+/, "");

  if (dereferenced.startsWith("map[")) return {};
  if (dereferenced.startsWith("[]")) return [];
  if (/\bbool\b/.test(dereferenced)) return false;
  if (/\b(?:u?int(?:8|16|32|64)?|float(?:32|64)?|double|decimal)\b/.test(dereferenced)) return 0;
  return "TODO";
}

function toSingleQuotedJsonPayload(payload) {
  return JSON.stringify(payload, null, 2).replace(/'/g, "\\'");
}

export function buildDocStub({ method, params = [] }) {
  const safeParams = Array.isArray(params) ? params : [];
  const tableRows =
    safeParams.length > 0
      ? safeParams.map((param) => `| ${param.name} | ${param.type} | TODO | Optional |`).join("\n")
      : "| (none) | - | This method currently has no named struct params. | Optional |";

  const exampleParams = {};
  for (const param of safeParams) {
    exampleParams[param.name] = inferExampleValue(param.type);
  }

  const requestPayload = {
    jsonrpc: "2.0",
    method,
    params: exampleParams,
    id: 1,
  };
  const responsePayload = {
    id: 1,
    result: {},
    error: null,
  };

  return `# ${method}
Auto-generated API documentation stub. Replace TODO placeholders with method-specific details.
<hr>

### Parameters

| Name | Type | Description | Required |
| --- | --- | --- | --- |
${tableRows}

### Example

Request body

\`\`\`bash
curl --location --request POST 'https://testneofura.ngd.network:444' \\
--header 'Content-Type: application/json' \\
--data-raw '${toSingleQuotedJsonPayload(requestPayload)}'
\`\`\`

Response body

\`\`\`json
${JSON.stringify(responsePayload, null, 2)}
\`\`\`
`;
}

function printList(label, values) {
  if (values.length === 0) return;
  console.log(`\n${label} (${values.length}):`);
  for (const value of values) {
    console.log(`- ${value}`);
  }
}

async function collectDocsMethods(backendDocsFiles) {
  const docsMethods = new Set();
  for (const file of backendDocsFiles) {
    const content = await fs.readFile(file, "utf8");
    for (const method of collectMatches(content, [docsMethodPattern])) {
      if (!docsNoiseMethods.has(method)) docsMethods.add(method);
    }
  }
  return docsMethods;
}

async function collectBackendMethodArgs(backendApiFiles) {
  const argsByMethod = new Map();
  for (const file of backendApiFiles) {
    const content = await fs.readFile(file, "utf8");
    for (const method of collectMatches(content, [backendHandlerPattern])) {
      if (argsByMethod.has(method)) continue;
      argsByMethod.set(method, extractMethodArgsFromApiSource(content, method));
    }
  }
  return argsByMethod;
}

const autogeneratedDocMarker = "Auto-generated API documentation stub.";
const reservedDocMarker = "Legacy allowlisted API name reserved for compatibility.";

export function isAutogeneratedDocContent(content) {
  if (!content || typeof content !== "string") return false;
  return content.includes(autogeneratedDocMarker);
}

export function isReservedDocContent(content) {
  if (!content || typeof content !== "string") return false;
  return content.includes(reservedDocMarker);
}

async function syncBackendDocStubs({ methods, docsDir, argsByMethod, refreshAutogeneratedDocs }) {
  const createdFiles = [];
  const updatedFiles = [];

  for (const method of methods) {
    const fileName = methodToDocFileName(method);
    if (!fileName) continue;

    const docPath = path.join(docsDir, fileName);
    const content = buildDocStub({
      method,
      params: argsByMethod.get(method) ?? [],
    });

    if (!(await exists(docPath))) {
      await fs.writeFile(docPath, content, "utf8");
      createdFiles.push(docPath);
      continue;
    }

    if (!refreshAutogeneratedDocs) continue;

    const existing = await fs.readFile(docPath, "utf8");
    if (!existing.includes(autogeneratedDocMarker)) continue;
    if (existing === content) continue;

    await fs.writeFile(docPath, content, "utf8");
    updatedFiles.push(docPath);
  }
  return { createdFiles, updatedFiles };
}

async function main() {
  const requiredPaths = [
    frontendSourceDir,
    frontendApiDocsCatalogPath,
    backendApiConfig,
    backendApiDir,
    backendDocsDir,
  ];
  for (const requiredPath of requiredPaths) {
    if (!(await exists(requiredPath))) {
      console.error(`Missing required path: ${requiredPath}`);
      process.exit(1);
    }
  }

  const frontendFiles = await walkFiles(frontendSourceDir, (file) =>
    [".js", ".ts", ".vue"].some((ext) => file.endsWith(ext))
  );
  const backendApiFiles = await walkFiles(backendApiDir, (file) => file.endsWith(".go"));
  let backendDocsFiles = await walkFiles(backendDocsDir, (file) => file.endsWith(".md"));

  const frontendMethods = new Set();
  for (const file of frontendFiles) {
    const content = await fs.readFile(file, "utf8");
    for (const method of collectMatches(content, frontendPatterns)) {
      frontendMethods.add(method);
    }
  }

  const apiDocsCatalogModule = await import(pathToFileURL(frontendApiDocsCatalogPath).href);
  const apiDocsCategories = Array.isArray(apiDocsCatalogModule.API_DOCS_RPC_CATEGORIES)
    ? apiDocsCatalogModule.API_DOCS_RPC_CATEGORIES
    : [];
  const apiDocsMethods = Array.isArray(apiDocsCatalogModule.API_DOCS_RPC_METHODS)
    ? apiDocsCatalogModule.API_DOCS_RPC_METHODS
    : [];
  const apiDocsPassthroughMethods =
    apiDocsCatalogModule.API_DOCS_RPC_PASSTHROUGH_METHODS instanceof Set
      ? apiDocsCatalogModule.API_DOCS_RPC_PASSTHROUGH_METHODS
      : new Set();

  const backendHandlers = new Set();
  for (const file of backendApiFiles) {
    const content = await fs.readFile(file, "utf8");
    for (const method of collectMatches(content, [backendHandlerPattern])) {
      backendHandlers.add(method);
    }
  }

  const backendHandlerCoverage = buildHandlerCoverageSet(backendHandlers);
  const backendConfigContent = await fs.readFile(backendApiConfig, "utf8");
  const backendAllowedApis = collectMatches(backendConfigContent, [backendApiAllowlistPattern]);

  let docsMethods = await collectDocsMethods(backendDocsFiles);

  const backendAllowedSorted = sorted(backendAllowedApis);
  let docsSorted = sorted(docsMethods);
  let backendUndocumented = backendAllowedSorted.filter((method) => !docsMethods.has(method));

  if (writeMissingBackendDocs || refreshAutogeneratedBackendDocs) {
    const argsByMethod = await collectBackendMethodArgs(backendApiFiles);
    const syncMethods = refreshAutogeneratedBackendDocs ? backendAllowedSorted : backendUndocumented;
    const { createdFiles, updatedFiles } = await syncBackendDocStubs({
      methods: syncMethods,
      docsDir: backendDocsDir,
      argsByMethod,
      refreshAutogeneratedDocs: refreshAutogeneratedBackendDocs,
    });

    if (createdFiles.length > 0 || updatedFiles.length > 0) {
      backendDocsFiles = await walkFiles(backendDocsDir, (file) => file.endsWith(".md"));
      docsMethods = await collectDocsMethods(backendDocsFiles);
      docsSorted = sorted(docsMethods);
      backendUndocumented = backendAllowedSorted.filter((method) => !docsMethods.has(method));

      const createdRelative = createdFiles.map((file) => path.relative(backendRoot, file));
      const updatedRelative = updatedFiles.map((file) => path.relative(backendRoot, file));
      printList("Generated backend doc stubs", createdRelative);
      printList("Refreshed autogenerated backend doc stubs", updatedRelative);
    }
  }

  const frontendSorted = sorted(frontendMethods);
  const apiDocsMethodNames = sorted(
    apiDocsMethods.map((method) => method?.name).filter((methodName) => typeof methodName === "string")
  );
  const apiDocsCatalogIssues = collectApiDocsCatalogIssues({
    categories: apiDocsCategories,
    methods: apiDocsMethods,
    passthroughMethods: apiDocsPassthroughMethods,
  });
  const apiDocsCatalogUsageIssues = collectApiDocsCatalogUsageIssues({
    catalogMethodNames: apiDocsMethodNames,
    frontendMethodNames: frontendMethods,
  });

  const frontendMissingInBackend = findMissingMethods({
    requiredMethods: frontendSorted,
    availableMethods: backendAllowedApis,
    exemptMethods: passthroughMethods,
  });
  const frontendMissingInHandlers = findMissingMethods({
    requiredMethods: frontendSorted,
    availableMethods: backendHandlerCoverage,
    exemptMethods: passthroughMethods,
  });
  const frontendMissingInDocs = frontendSorted.filter(
    (method) => !docsMethods.has(method) && !passthroughMethods.has(method)
  );
  const frontendPassthrough = frontendSorted.filter((method) => passthroughMethods.has(method));
  const frontendDocFileMissing = [];
  const frontendDocFileMethodMismatch = [];
  const frontendDocFileAutogenerated = [];
  const frontendDocFileReserved = [];
  const apiDocsMissingInBackendAllowlist = findMissingMethods({
    requiredMethods: apiDocsMethodNames,
    availableMethods: backendAllowedApis,
    exemptMethods: apiDocsPassthroughMethods,
  });
  const apiDocsMissingInHandlers = findMissingMethods({
    requiredMethods: apiDocsMethodNames,
    availableMethods: backendHandlerCoverage,
    exemptMethods: apiDocsPassthroughMethods,
  });
  const apiDocsMissingInBackendDocs = apiDocsMethodNames.filter(
    (method) => !docsMethods.has(method) && !apiDocsPassthroughMethods.has(method)
  );
  const apiDocsDocFileAutogenerated = [];
  const apiDocsDocFileReserved = [];
  const apiDocsDocFileMethodMismatch = [];

  for (const method of frontendSorted) {
    if (passthroughMethods.has(method)) continue;

    const docFile = methodToDocFileName(method);
    const docPath = path.join(backendDocsDir, docFile);

    if (!(await exists(docPath))) {
      frontendDocFileMissing.push(method);
      continue;
    }

    const docContent = await fs.readFile(docPath, "utf8");
    if (isAutogeneratedDocContent(docContent)) {
      frontendDocFileAutogenerated.push(method);
    }
    if (isReservedDocContent(docContent)) {
      frontendDocFileReserved.push(method);
    }
    const methodPattern = new RegExp(`"method"\\s*:\\s*"${escapeRegExp(method)}"`);
    if (!methodPattern.test(docContent)) {
      frontendDocFileMethodMismatch.push(method);
    }
  }

  for (const method of apiDocsMethodNames) {
    if (apiDocsPassthroughMethods.has(method)) continue;
    const docFile = methodToDocFileName(method);
    const docPath = path.join(backendDocsDir, docFile);
    if (!(await exists(docPath))) continue;
    const docContent = await fs.readFile(docPath, "utf8");
    if (isAutogeneratedDocContent(docContent)) {
      apiDocsDocFileAutogenerated.push(method);
    }
    if (isReservedDocContent(docContent)) {
      apiDocsDocFileReserved.push(method);
    }
    const methodPattern = new RegExp(`"method"\\s*:\\s*"${escapeRegExp(method)}"`);
    if (!methodPattern.test(docContent)) {
      apiDocsDocFileMethodMismatch.push(method);
    }
  }

  const docsMissingInBackend = docsSorted.filter(
    (method) => !backendAllowedApis.has(method) && !passthroughMethods.has(method)
  );
  const backendAllowlistedMissingHandlers = findMissingMethods({
    requiredMethods: backendAllowedSorted,
    availableMethods: backendHandlerCoverage,
  });
  const backendMissingHandlersWithoutReservedDocs = [];

  for (const method of backendAllowlistedMissingHandlers) {
    const docFile = methodToDocFileName(method);
    const docPath = path.join(backendDocsDir, docFile);
    if (!(await exists(docPath))) {
      backendMissingHandlersWithoutReservedDocs.push(method);
      continue;
    }

    const docContent = await fs.readFile(docPath, "utf8");
    if (!isReservedDocContent(docContent)) {
      backendMissingHandlersWithoutReservedDocs.push(method);
    }
  }

  console.log("RPC Consistency Report");
  console.log("======================");
  console.log(`Frontend methods found: ${frontendSorted.length}`);
  console.log(`API docs catalog methods found: ${apiDocsMethodNames.length}`);
  console.log(`Backend allowlisted APIs: ${backendAllowedSorted.length}`);
  console.log(`Backend handlers found: ${backendHandlers.size}`);
  console.log(`Backend docs methods found: ${docsSorted.length}`);

  printList("Frontend methods using native passthrough", frontendPassthrough);
  printList("Frontend methods missing in backend API allowlist", frontendMissingInBackend);
  printList("Frontend methods missing backend handlers", frontendMissingInHandlers);
  printList("Frontend methods missing in backend docs", frontendMissingInDocs);
  printList("Frontend methods missing dedicated backend doc files", frontendDocFileMissing);
  printList("Frontend methods documented only by autogenerated placeholder docs", frontendDocFileAutogenerated);
  printList("Frontend methods mapped to reserved compatibility docs", frontendDocFileReserved);
  printList("Frontend methods with mismatched method names in their backend doc files", frontendDocFileMethodMismatch);
  printList("API docs catalog duplicate category keys", apiDocsCatalogIssues.duplicateCategoryKeys);
  printList("API docs catalog duplicate method names", apiDocsCatalogIssues.duplicateMethodNames);
  printList("API docs methods with unknown categories", apiDocsCatalogIssues.methodsWithUnknownCategory);
  printList(
    "API docs passthrough methods with non-passthrough types",
    apiDocsCatalogIssues.passthroughMethodTypeMismatches
  );
  printList(
    "API docs methods typed as passthrough but missing from passthrough method set",
    apiDocsCatalogIssues.passthroughTypeMissingFromSet
  );
  printList(
    "API docs catalog methods not referenced by frontend RPC usage",
    apiDocsCatalogUsageIssues.catalogMethodsMissingInFrontendUsage
  );
  printList("API docs methods missing in backend API allowlist", apiDocsMissingInBackendAllowlist);
  printList("API docs methods missing backend handlers", apiDocsMissingInHandlers);
  printList("API docs methods missing in backend docs", apiDocsMissingInBackendDocs);
  printList("API docs methods documented only by autogenerated placeholder docs", apiDocsDocFileAutogenerated);
  printList("API docs methods mapped to reserved compatibility docs", apiDocsDocFileReserved);
  printList("API docs methods with mismatched method names in backend doc files", apiDocsDocFileMethodMismatch);
  printList("Docs methods missing in backend allowlist", docsMissingInBackend);
  printList("Backend allowlisted methods missing in docs", backendUndocumented);
  printList("Backend allowlisted methods missing handler coverage", backendAllowlistedMissingHandlers);
  printList(
    "Backend allowlisted methods missing handlers but not marked as reserved docs",
    backendMissingHandlersWithoutReservedDocs
  );

  if (frontendMissingInBackend.length > 0) {
    console.error("\nValidation failed: frontend references unsupported backend methods.");
    process.exit(1);
  }

  if (frontendMissingInHandlers.length > 0) {
    console.error("\nValidation failed: frontend references backend methods without handlers.");
    process.exit(1);
  }

  const hasApiDocsCatalogIssues =
    apiDocsCatalogIssues.duplicateCategoryKeys.length > 0 ||
    apiDocsCatalogIssues.duplicateMethodNames.length > 0 ||
    apiDocsCatalogIssues.methodsWithUnknownCategory.length > 0 ||
    apiDocsCatalogIssues.passthroughMethodTypeMismatches.length > 0 ||
    apiDocsCatalogIssues.passthroughTypeMissingFromSet.length > 0;

  if (hasApiDocsCatalogIssues) {
    console.error("\nValidation failed: API docs catalog has structural consistency issues.");
    process.exit(1);
  }

  if (apiDocsCatalogUsageIssues.catalogMethodsMissingInFrontendUsage.length > 0) {
    console.error("\nValidation failed: API docs catalog includes methods not referenced by frontend RPC usage.");
    process.exit(1);
  }

  if (apiDocsMissingInBackendAllowlist.length > 0) {
    console.error("\nValidation failed: API docs catalog references methods missing from backend allowlist.");
    process.exit(1);
  }

  if (apiDocsMissingInHandlers.length > 0) {
    console.error("\nValidation failed: API docs catalog references methods without backend handlers.");
    process.exit(1);
  }

  if (apiDocsMissingInBackendDocs.length > 0) {
    console.error("\nValidation failed: API docs catalog references methods missing backend docs.");
    process.exit(1);
  }

  if (
    apiDocsDocFileAutogenerated.length > 0 ||
    apiDocsDocFileReserved.length > 0 ||
    apiDocsDocFileMethodMismatch.length > 0
  ) {
    console.error("\nValidation failed: API docs catalog methods are not fully documented by production-ready backend docs.");
    process.exit(1);
  }

  const hasFrontendDocGaps =
    frontendMissingInDocs.length > 0 ||
    frontendDocFileMissing.length > 0 ||
    frontendDocFileAutogenerated.length > 0 ||
    frontendDocFileReserved.length > 0 ||
    frontendDocFileMethodMismatch.length > 0;

  if (hasFrontendDocGaps) {
    const message = "\nValidation warning: frontend methods are not fully documented in backend docs.";
    if (failOnFrontendDocGaps) {
      console.error(message);
      process.exit(1);
    }
    console.warn(message);
  }

  if (docsMissingInBackend.length > 0) {
    console.error("\nValidation failed: docs reference methods missing from backend API allowlist.");
    process.exit(1);
  }

  if (backendUndocumented.length > 0 && failOnBackendUndocumented) {
    console.error("\nValidation failed: backend allowlisted methods are missing docs.");
    process.exit(1);
  }

  if (backendMissingHandlersWithoutReservedDocs.length > 0) {
    const message =
      "\nValidation warning: some allowlisted backend methods have no handlers and are not documented as reserved compatibility APIs.";
    if (failOnBackendUndocumented) {
      console.error(message);
      process.exit(1);
    }
    console.warn(message);
  }

  console.log("\nValidation passed.");
}

const isDirectExecution =
  typeof process.argv[1] === "string" && import.meta.url === pathToFileURL(process.argv[1]).href;

if (isDirectExecution) {
  main().catch((error) => {
    console.error(error);
    process.exit(1);
  });
}
